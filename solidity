// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";

/**
 * @title GreatLoveImmortalLord (大爱仙尊)
 * @dev 融合东方文化的智能合约代币，体现"大爱无疆，仙尊护佑"的理念
 * 结合传统文化元素与现代DeFi功能，创造独特的价值体系
 */
contract GreatLoveImmortalLord is ERC20, ERC20Burnable, ERC20Pausable, AccessControl, ReentrancyGuard, ERC20Permit {
    
    // 角色定义 - 融入仙侠文化特色
    bytes32 public constant DAO_ZHU_XIANG = keccak256("DAO_ZHU_XIANG"); // 道主
    bytes32 public constant ZHENG_TIAN_XIAN_ZUN = keccak256("ZHENG_TIAN_XIAN_ZUN"); // 证天仙尊
    bytes32 public constant YUAN_DAO_XIAN_SHENG = keccak256("YUAN_DAO_XIAN_SHENG"); // 缘道先生
    bytes32 public constant PU_SA_HU_FA = keccak256("PU_SA_HU_FA"); // 菩萨护法
    
    // 文化主题常量
    string public constant CULTURE_MOTTO = "大爱无疆，仙尊护佑";
    string public constant PHILOSOPHY = "以德服人，以爱渡世";
    
    // 代币配置
    uint8 public constant DECIMALS = 18;
    uint256 public constant INITIAL_BLESSING = 888_888_888 * 10**DECIMALS; // 初始祝福总量 8.888亿
    uint256 public constant MAX_CELESTIAL_SUPPLY = 999_999_999 * 10**DECIMALS; // 天道极限 9.999亿
    
    // 功德系统 - 体现东方文化中的功德概念
    struct MeritRecord {
        uint256 accumulatedMerit;    // 累积功德值
        uint256 lastMeritTime;      // 最后功德时间
        uint256 blessingLevel;      // 祝福等级 (1-9品)
        uint256 donationCount;      // 布施次数
    }
    
    mapping(address => MeritRecord) public meritRecords;
    uint256 public totalMeritInCirculation;
    
    // 仙缘值系统 - 社交化功能
    mapping(address => mapping(address => uint256)) public celestialConnections; // 仙缘关系
    uint256 public totalCelestialConnections;
    
    // 灵气值系统 - 持币时间和数量的奖励
    mapping(address => uint256) public spiritualEnergy; // 灵气值
    uint256 public totalSpiritualEnergy;
    
    // 文化参数
    uint256 public blessingRate = 88; // 祝福费率 0.88% (基点)
    uint256 public meritBurnRate = 13; // 功德燃烧率 13% (吉利数字)
    uint256 public connectionRewardRate = 66; // 仙缘奖励率 0.66%
    
    // 特殊地址
    address public blessedOne; // 受祝福者 (初始创建者)
    address public celestialDao; // 天道议会
    
    // 事件 - 融入文化元素
    event BlessingConferred(address indexed from, address indexed to, uint256 amount, string blessing);
    event MeritAccumulated(address indexed believer, uint256 merit, uint256 level);
    event CelestialConnectionForged(address indexed master, address indexed disciple, uint256 bondStrength);
    event SpiritualEnergyCultivated(address indexed cultivator, uint256 energyGained);
    event DaoHeartManifested(address indexed daoMember, string action, uint256 impact);
    
    // 祝福类型
    enum BlessingType {
        GOLDEN_LOTUS,    // 金莲祝福 - 最高级
        JADE_PURE,       // 玉清祝福
        HEAVEN_PEACE,    // 天和祝福
        EARTH_HARMONY,   // 地和祝福
        COMMON_BLESSING  // 普通祝福
    }
    
    constructor(address initialBlessedOne) 
        ERC20("Great Love Immortal Lord", "大爱仙尊") 
        ERC20Permit("Great Love Immortal Lord") 
    {
        require(initialBlessedOne != address(0), "Invalid blessed one");
        
        blessedOne = initialBlessedOne;
        celestialDao = initialBlessedOne;
        
        // 建立角色体系
        _grantRole(DEFAULT_ADMIN_ROLE, initialBlessedOne);
        _grantRole(DAO_ZHU_XIANG, initialBlessedOne);
        _grantRole(ZHENG_TIAN_XIAN_ZUN, initialBlessedOne);
        _grantRole(YUAN_DAO_XIAN_SHENG, initialBlessedOne);
        _grantRole(PU_SA_HU_FA, initialBlessedOne);
        
        // 首次祝福 - 道祖赐福
        _mint(initialBlessedOne, INITIAL_BLESSING);
        
        // 初始化功德记录
        meritRecords[initialBlessedOne] = MeritRecord({
            accumulatedMerit: INITIAL_BLESSING / 100, // 初始功德
            lastMeritTime: block.timestamp,
            blessingLevel: 9, // 九品仙尊
            donationCount: 0
        });
        
        emit BlessingConferred(address(0), initialBlessedOne, INITIAL_BLESSING, "道祖初赐福");
    }
    
    /**
     * @dev 传播祝福 - 转账时触发功德计算
     */
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override whenNotPaused nonReentrant {
        require(from != address(0), "Transfer from void");
        require(to != address(0), "Transfer to void");
        require(amount > 0, "Blessing must be positive");
        
        // 计算祝福中的功德成分
        uint256 meritComponent = (amount * blessingRate) / 10000;
        uint256 pureTransfer = amount - meritComponent;
        
        // 功德燃烧 - 13% 归天道
        uint256 meritBurn = (meritComponent * meritBurnRate) / 100;
        if (meritBurn > 0) {
            super._burn(from, meritBurn);
            totalMeritInCirculation += meritBurn;
        }
        
        // 执行转账
        super._transfer(from, to, pureTransfer);
        
        // 更新功德记录
        _updateMeritRecord(from, to, meritComponent - meritBurn);
        
        // 培养灵气值
        _cultivateSpiritualEnergy(to, pureTransfer);
        
        // 触发祝福事件
        _emitBlessingEvent(from, to, pureTransfer);
    }
    
    /**
     * @dev 更新功德记录
     */
    function _updateMeritRecord(address from, address to, uint256 merit) private {
        // 更新接收者功德
        MeritRecord storage toRecord = meritRecords[to];
        toRecord.accumulatedMerit += merit;
        toRecord.lastMeritTime = block.timestamp;
        
        // 提升祝福等级
        if (toRecord.blessingLevel < 9) {
            uint256 requiredMerit = (toRecord.blessingLevel + 1) * 1000 * 10**DECIMALS;
            if (toRecord.accumulatedMerit >= requiredMerit) {
                toRecord.blessingLevel++;
                emit MeritAccumulated(to, toRecord.accumulatedMerit, toRecord.blessingLevel);
            }
        }
        
        // 更新发送者记录
        MeritRecord storage fromRecord = meritRecords[from];
        fromRecord.donationCount++; // 增加布施次数
    }
    
    /**
     * @dev 培养灵气值
     */
    function _cultivateSpiritualEnergy(address cultivator, uint256 amount) private {
        uint256 energyGained = (amount * spiritualEnergy[cultivator]) / (balanceOf(cultivator) + amount);
        energyGained = (energyGained * 100) / 88; // 88法则增益
        
        spiritualEnergy[cultivator] += energyGained;
        totalSpiritualEnergy += energyGained;
        
        emit SpiritualEnergyCultivated(cultivator, energyGained);
    }
    
    /**
     * @dev 缔结仙缘 - 建立师徒或道友关系
     */
    function forgeCelestialConnection(address disciple, uint256 bondStrength) 
        external 
        nonReentrant 
        whenNotPaused 
    {
        require(disciple != address(0), "Invalid disciple");
        require(bondStrength > 0, "Bond strength must be positive");
        require(balanceOf(msg.sender) >= bondStrength * 10**DECIMALS, "Insufficient cultivation base");
        
        celestialConnections[msg.sender][disciple] = bondStrength;
        totalCelestialConnections += bondStrength;
        
        // 双方获得仙缘奖励
        uint256 reward = (bondStrength * connectionRewardRate) / 10000;
        if (reward > 0) {
            _mint(msg.sender, reward);
            _mint(disciple, reward);
        }
        
        emit CelestialConnectionForged(msg.sender, disciple, bondStrength);
    }
    
    /**
     * @dev 功德回向 - 向指定地址传送功德
     */
    function meritDedication(address beneficiary, uint256 meritAmount) 
        external 
        nonReentrant 
        whenNotPaused 
    {
        require(beneficiary != address(0), "Invalid beneficiary");
        require(balanceOf(msg.sender) >= meritAmount, "Insufficient blessings");
        
        // 转移功德
        super._transfer(msg.sender, beneficiary, meritAmount);
        
        // 双方功德增益
        MeritRecord storage senderRecord = meritRecords[msg.sender];
        MeritRecord storage beneficiaryRecord = meritRecords[beneficiary];
        
        senderRecord.accumulatedMerit += meritAmount / 10; // 回向者也得功德
        beneficiaryRecord.accumulatedMerit += meritAmount;
        beneficiaryRecord.lastMeritTime = block.timestamp;
